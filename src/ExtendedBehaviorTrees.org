#+TITLE: Extended Behavior Trees
#+AUTHOR: Matthias Hölzl
#+EMAIL: tc@xantira.com
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4wide]
#+LATEX_HEADER: \usepackage{a4wide}
#+PROPERTY: header-args       :results silent
#+PROPERTY: header-args:julia :session *julia* 
#+PROPERTY: tangle            yes

* About this document

The source of this document is an Org-Mode file that contains text,
spreadsheets, some Emacs-Lisp code and Julia source code.  To evaluate
it, you need Jula 0.4 and Emacs with Org-Mode and ESS (Emacs Speaks
Statistics).  Emacs/Org-Mode/ESS have to be configured to work with
your Julia implementation.  If you don't have any of these things
available you will still be able to read the pre-generated output, but
you will not be able to recreate the results.

To evaluate all code in this file evaluate ~org-babel-execute-buffer~.

The whole file is in the ~ExtendedBehaviorTrees~ module. Let's add a
warning at the beginning of the file so that people don't accidentally
edit the generated source.  And disable evaluation inside Org-Mode,
since this causes the Julia process to hang.

#+BEGIN_SRC julia :eval never
  # GENERATED FROM ExtendedBehaviorTrees.org.
  # DO NOT EDIT THIS FILE!

  # Copyright © 2014, Matthias Hölzl
  # Licensed under the MIT license, see the file LICENSE.md.

  module ExtendedBehaviorTrees
#+END_SRC

This is a fix to make the current version of ESS work with Julia 0.4;
it should not be included in the tangled output, and it should be
removed once ESS is updated.

* Extended Behavior Trees

Behavior Trees (BTs) are a flexible approach for behavioral modeling.
BTs were originally introduced to model the AI of computer games, and
they have recently been become more popular in areas such as robotics
or avionics.  Here we implement /Extended behavior trees (XBTs)/, an
extension of behavior trees that support various kinds of reasoning
and learning beyond the reactive planning of BTs.

* Types for XBTs

For each tick of an XBT, the nodes return either /succeeded/, /failed/
or /running/, and an indication whether they can improve the result
they have obtained so far.  This is expressed by the following type
definitions.

#+BEGIN_SRC julia
  abstract XbtNodeStatus;
  immutable Succeeded <: XbtNodeStatus
      value
  end;
  immutable Failed <: XbtNodeStatus end;
  immutable Running <: XbtNodeStatus end;
  typealias XbtResult (XbtNodeStatus,Bool);
#+END_SRC

We execute nodes in an environment; details to be determined later.
#+BEGIN_SRC julia
  type Env
  end;
#+END_SRC

Nodes in XBTs can either be composite (if they have children) or
atomic.  We parameterize the classes in the type of the utility they
return.

#+BEGIN_SRC julia
  abstract XbtNode;
  abstract AtomicXbtNode <: XbtNode;
  abstract CompositeXbtNode <: XbtNode;
#+END_SRC

We allow two kinds of atomic nodes: ~XbtTask~ and ~XbtFun~.  Tasks are
the more general nodes that are invoked as coroutines so that they can
suspend their computation while they are still running.  Instances of
~XbtFun~ are simply wrappers around functions that succeed or fail but
don't suspend.  (Maybe we should simply allow functions as leaves?)

#+BEGIN_SRC julia
  immutable XbtTask <: AtomicXbtNode
      task::Task
  end;

  function tick(node::XbtTask, env)
      consume(node.task);
  end;

  immutable XbtFun <: AtomicXbtNode
      fun::Function
  end;

  function tick(node::XbtFun, Env)
      node.fun();
  end;
#+END_SRC

And example for a simple task would be the following:
#+BEGIN_SRC julia :tangle no
  function mytask()
      for i=1:3
          produce((Running(), true));
      end
      produce((Succeeded(1), false));
  end;
  task1 = XbtTask(Task(mytask));
  env = Env();
  tick(task1, env)
  tick(task1, env)
  tick(task1, env)
  tick(task1, env)
#+END_SRC

The simplest kinds of composite XBT nodes are sequences and choices.
A Sequence executes its child nodes sequentially until a child node
fails.  In that case the sequence node fails as well.  If all child
nodes succeed the sequence node succeeds.  Choice nodes work in the
reverse manner: They execute their children in turn until the first
child succeeds in which case the choice succeeds.  If all children
fail the choice fails.  Since we will later have several nodes that
are sequence- or choice-like we define abstract types for these two
behaviors.

#+BEGIN_SRC julia
  abstract XbtSequenceNode <: CompositeXbtNode;

  function tick(node::XbtSequenceNode, env::Env)
      local sum = 0, status, cont;
      for child in node.children
          status, cont = tick(child);
          if isa(status, Failed) return (status, false) end;
          if isa(status, Running) return (status, true) end;
          sum += status.value;
      end;
      # TODO: what about continuing?
      return Succeeded(sum, false), cont;
  end;

  immutable XbtSeq <: XbtSequenceNode
      children::AbstractArray{XbtNode,1}
  end;

  abstract XbtChoiceNode <: CompositeXbtNode;

  function tick(node::XbtChoiceNode, env::Env)
      local status, cont;
      for child in node.children
          status, cont = tick(child);
          if isa(status, Succeeded) return (status, cont) end;
          if isa(status, Running) return (status, true) end;
      end;
      return Failed(), cont;
  end;

  immutable XbtChoice <: XbtChoiceNode
      children::AbstractArray{XbtNode,1}
  end;
#+END_SRC

* HTN Planning

** States and Goals

** The Planner

* Reinforcement Learning

#+BEGIN_SRC julia :eval never
  end; # module ExtendedBehaviorTrees
#+END_SRC
